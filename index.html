<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1.0, user-scalable=no">
<title>SYA</title>

<!-- PWA -->
<link rel="manifest" href="manifest.json"/>
<meta name="theme-color" content="#000000">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<!-- FUENTES / ICONOS -->
<link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;500&display=swap" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght@300" rel="stylesheet"/>

<style>
:root{
  --primary:#ffa0e5;
  --text:#fff;
  --glass:rgba(0,0,0,.4);
  --notif-bg:#ff3b30;
  --notif-shadow:rgba(255,59,48,0.45);
}

/* -------------------------
   GLOBAL / RESET
   ------------------------- */
*{margin:0;padding:0;box-sizing:border-box;-webkit-user-select:none;user-select:none;}
html,body{
  width:100%;
  height:100dvh;
  min-height:100vh;
  font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;
  color:var(--text);
  overflow:hidden;
  background:#000;
  -webkit-text-size-adjust:100%;
}
.material-symbols-outlined{font-size:2rem;}

/* -------------------------
   LOCKSCREEN
   ------------------------- */
#lockScreen{
  position:fixed;inset:0;display:flex;flex-direction:column;justify-content:center;align-items:center;
  background:url("momentos/foto0.JPG") no-repeat center/cover;
  transition:transform .7s ease-in-out;z-index:30;
}
#lockScreen::after{content:"";position:absolute;inset:0;background:rgba(0,0,0,.35);pointer-events:none;}
.lockContent{
  position:relative;display:flex;flex-direction:column;align-items:center;z-index:1;width:100%;
  padding-top:env(safe-area-inset-top);padding-bottom:env(safe-area-inset-bottom);
}
.heart{
  position:relative;
  font-size:3rem;margin-bottom:1rem;animation:heartbeat 1.8s infinite;
  will-change:transform;
}
@keyframes heartbeat{0%,100%{transform:scale(1);}50%{transform:scale(1.18);}}
#newBadge{
  font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;position:absolute;top:0;right:-4px;
  background:var(--notif-bg);color:#fff;font-size:.8rem;font-weight:700;
  border-radius:999px;padding:.20rem .40rem;display:none;opacity:0;transform:scale(.5);
  transition:transform .36s cubic-bezier(.2,.9,.3,1), opacity .36s;
  pointer-events:none;
}
#newBadge.show{display:inline-block;opacity:1;transform:scale(1);}
#message{font-size:1.05rem;margin-bottom:1rem;min-height:1.4rem;opacity:0;transition:opacity .3s;}
#message.show{opacity:1;}
#pinDots{display:flex;gap:.5rem;margin-bottom:1rem;}
.dot{width:.9rem;height:.9rem;border-radius:50%;border:2px solid var(--text);background:transparent;transition:.18s;}
.dot.filled{background:var(--text);}
#keypad{
  display:grid;grid-template-columns:repeat(3,min(20vw,70px));gap:1rem;justify-content:center;
}
.key{
  width:min(20vw,70px);height:min(20vw,70px);border-radius:50%;
  background:var(--glass);color:var(--text);display:flex;align-items:center;justify-content:center;
  font-size:2rem;cursor:pointer;backdrop-filter:blur(6px);transition:transform .12s;
  position:relative;overflow:hidden;touch-action:manipulation;
}
.key:active{transform:scale(.94);}

/* -------------------------
   TOPBAR
   ------------------------- */
#topbar{
  position:fixed;top:env(safe-area-inset-top,0);left:0;right:0;z-index:25;
  display:none;justify-content:center;padding:.6rem 1rem;
}
.searchWrap{flex:1;max-width:700px;display:flex;align-items:center;gap:.5rem;background:var(--glass);backdrop-filter:blur(6px);border-radius:999px;padding:.35rem .75rem;}
.searchWrap .icon{font-size:26px;opacity:.9;}
#slideSearch{width: 80px;flex:1;border:none;outline:none;background:transparent;color:var(--text);font-size:17px;padding:.35rem 0;}
.counter{width: 40px;text-align: center;font-size: 18px;font-variant-numeric:tabular-nums;opacity:.9;white-space:nowrap;}
#refreshBtn{
  background:var(--glass);border:none;border-radius:50%;width:30px;height:30px;
  display:flex;align-items:center;justify-content:center;cursor:pointer;margin-left:.5rem;color:var(--text);
  transition:transform .22s,opacity .22s;
  font-size: 26px;
}
#refreshBtn.disabled{
  opacity:0.4;
  pointer-events:none;
}
#refreshBtn.refreshing{animation:spin-continuous .9s linear infinite;}
@keyframes spin-continuous{from{transform:rotate(0);}to{transform:rotate(360deg);}}
#refreshBtn:active{animation:spin-bounce .6s ease;}
@keyframes spin-bounce{0%{transform:scale(.9) rotate(0);}50%{transform:scale(1.15) rotate(180deg);}100%{transform:scale(1) rotate(360deg);}}

/* -------------------------
   STORIES
   ------------------------- */
#stories{
  position:fixed;inset:0;background: #000;overflow:hidden;/**url("https://lh3.googleusercontent.com/d/1TDaFB4VaF33SLlw73SX4k7x_tXWtxYac") #000;background-position: center;background-size: cover;**/
  transform:translateY(100%);transition:transform .7s ease-in-out;z-index:20;
}
#track{
  width:100%;height:100%;
  will-change:transform;
  touch-action:none;display:block;
  transform:translate3d(0,0,0);
}
.story{
  height:100vh;
  width:100%;
  display:flex;
  flex-direction:column;
  justify-content:center;
  align-items:center;
  text-align:center;
  position:relative;
  padding:2rem;
  padding-top:calc(env(safe-area-inset-top) + 1rem);
  padding-bottom:calc(env(safe-area-inset-bottom) + 1rem);
  background-size:cover;
  background-position:center;
  will-change:transform;
}
.story::after{
  content:"";position:absolute;inset:0;background:linear-gradient(to bottom,#00000044,#000000aa);
  pointer-events:none;transition:background .28s;
}
.storyContent{position:relative;z-index:1;max-width:900px;margin:0 auto;padding:0 1rem;}
.story h2{font-family:"Dancing Script",cursive;font-size:2rem;margin-bottom:.5rem;text-shadow:0 1px 3px rgba(0,0,0,0.5);}
.story .date{font-size:1rem;opacity:.85;margin-bottom:1rem;text-shadow:0 1px 2px rgba(0,0,0,0.6);}
.story p{font-size:1.06rem;line-height:1.45;text-shadow:0 1px 2px rgba(0,0,0,0.6);}
@media(min-width:768px){.story h2{font-size:2.4rem}.story p{font-size:1.15rem}}
.story.newItem::after{
  background:linear-gradient(to bottom, rgba(255,59,48,0.32), rgba(0,0,0,0.92));
  box-shadow: inset 0 0 40px var(--notif-shadow);
}
.track-refreshing {filter: brightness(.98) saturate(.98);transition: filter .35s ease;}

/* -------------------------
   VIDEO & SOUND BUTTON
   ------------------------- */
.story video.storyVideo{
  position:absolute;
  top:0;left:0;right:0;bottom:0;
  width:100%;
  height:100%;
  object-fit:cover;
  z-index:0;
}
.soundBtn{
  position:absolute;
  bottom:calc(1rem + env(safe-area-inset-bottom));
  right:1rem;
  z-index:2;
  background:var(--glass);
  border:none;
  border-radius:50%;
  padding:.5rem;
  color:var(--text);
  cursor:pointer;
  font-size:1.8rem;
  display:inline-flex;
  align-items:center;
  justify-content:center;
}
</style>
</head>
<body oncontextmenu="return false;">

<!-- LOCKSCREEN -->
<div id="lockScreen">
  <div class="lockContent">
    <span class="material-symbols-outlined heart" aria-hidden="true">
      favorite
      <span id="newBadge"></span>
    </span>
    <div id="message" class="show">Ingrese código</div>
    <div id="pinDots"></div>
    <div id="keypad" role="group" aria-label="Teclado numérico"></div>
  </div>
</div>

<!-- TOPBAR -->
<div id="topbar">
  <div class="searchWrap">
    <span class="material-symbols-outlined icon" aria-hidden="true">search</span>
    <label for="slideSearch" class="sr-only"></label>
    <input id="slideSearch" type="number" inputmode="numeric" pattern="[0-9]*" placeholder="Buscar recuerdo..."/>
    <div class="counter">
      <span id="currentIdx">1</span>/<span id="totalIdx">1</span>
    </div>
    <button id="refreshBtn" class="material-symbols-outlined" title="Refrescar" aria-label="Refrescar">refresh</button>
  </div>
</div>

<!-- STORIES -->
<div id="stories" aria-label="Historias de pareja">
  <div id="track" role="list"></div>
</div>

<script>
/* ===========================
   VERSION MEJORADA PARA SWIPE + LAZY-VIDEO + SEGURIDAD
   Reemplaza TODO el <script> anterior por este bloque.
   =========================== */
const appState = {
  PASSWORD_HASH: "4908ef154f13f297da224aceaa78fbbedfc12adf625611d8972b148c43c9e46d",
  PIN_LENGTH: 6,
  RECUERDOS_JSON: "recuerdos.json",
  recuerdos: [],
  N: 0,
  pos: 1,
  pageH: 0,
  dragging: false,
  animating: false,
  startY: 0,
  baseY: 0,
  latestDelta: 0,
  velocity: 0,
  lastMoveTime: 0,
  lastMoveY: 0,
  lastKnownCount: parseInt(localStorage.getItem("lastCount") || "0"),
  builtOnce: false,
  activePointerId: null,
  // timers to avoid stuck states
  transitionFallbackTimer: null,
  dragReleaseTimer: null
};

/* ELEMENTOS (mismos ids que tu HTML) */
const lockScreen = document.getElementById("lockScreen");
const dotsWrap = document.getElementById("pinDots");
const keypad = document.getElementById("keypad");
const msg = document.getElementById("message");
const topbar = document.getElementById("topbar");
const track = document.getElementById("track");
const stories = document.getElementById("stories");
const slideSearch = document.getElementById("slideSearch");
const currentIdxEl = document.getElementById("currentIdx");
const totalIdxEl = document.getElementById("totalIdx");
const newBadge = document.getElementById("newBadge");
const refreshBtn = document.getElementById("refreshBtn");

/* PIN DOTS */
const dotEls = [];
for(let i=0;i<appState.PIN_LENGTH;i++){
  const d = document.createElement("div");
  d.className = "dot";
  dotsWrap.appendChild(d);
  dotEls.push(d);
}

/* Mensajes */
function showMessage(text){
  msg.classList.remove("show");
  setTimeout(()=>{
    msg.textContent = text;
    msg.classList.add("show");
  },120);
}
function formateaFechaES(iso){
  try{
    const d = new Date(iso + "T12:00:00");
    const m = ["enero","febrero","marzo","abril","mayo","junio","julio","agosto","septiembre","octubre","noviembre","diciembre"];
    return `${d.getDate()} de ${m[d.getMonth()]} del ${d.getFullYear()}`;
  }catch(_){ return iso; }
}

/* KEYPAD */
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
function renderKeypad(){
  keypad.innerHTML = "";
  shuffle([...Array(10).keys()]).forEach(n=>{
    const k=document.createElement("div"); 
    k.className="key"; k.textContent=n; k.setAttribute("role","button"); k.setAttribute("aria-label","Número "+n);
    k.addEventListener("pointerdown",()=>enterDigit(n), {passive:true});
    keypad.appendChild(k);
  });
  const del=document.createElement("div"); 
  del.className="key material-symbols-outlined"; del.textContent="backspace"; del.setAttribute("role","button"); del.setAttribute("aria-label","Borrar");
  del.addEventListener("pointerdown", deleteDigit, {passive:true});
  keypad.appendChild(del);
}
renderKeypad();

/* Teclado físico */
document.addEventListener("keydown", e=>{
  if(e.key >= "0" && e.key <= "9") enterDigit(e.key);
  if(e.key === "Backspace") deleteDigit();
});

/* PIN LOGIC */
let input="";
async function hashPassword(pwd){
  const enc = new TextEncoder().encode(pwd);
  const buf = await crypto.subtle.digest("SHA-256", enc);
  return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,"0")).join("");
}
function enterDigit(n){
  if(input.length>=appState.PIN_LENGTH) return;
  input += String(n);
  dotEls[input.length-1].classList.add("filled");
  if(input.length===appState.PIN_LENGTH) checkPassword();
}
function deleteDigit(){
  if(input.length>0){
    dotEls[input.length-1].classList.remove("filled");
    input = input.slice(0,-1);
  }
}
async function checkPassword(){
  const h = await hashPassword(input);
  if(h === appState.PASSWORD_HASH){
    showMessage("✔ Desbloqueado!");
    lockScreen.style.transform = "translateY(-100%)";
    stories.style.transform = "translateY(0)";
    topbar.style.display = "flex";
  }else{
    input="";
    dotEls.forEach(d=>d.classList.remove("filled"));
    renderKeypad();
    showMessage("Código incorrecto");
  }
}

/* ===========================
   CREAR STORY: ahora VIDEO usa data-src para LAZY-LOAD
   =========================== */
function crearStory(item, originalIndex){
  const sec = document.createElement("section");
  sec.className = "story";
  sec.dataset.original = String(originalIndex);

  if(/\.(mp4|webm|ogg|mov)$/i.test(item.fondo)){
    // video con data-src (no src directo)
    sec.innerHTML = `
      <video class="storyVideo" muted playsinline loop preload="metadata" data-src="${item.fondo}"></video>
      <button class="soundBtn material-symbols-outlined" aria-label="Sonido" style="display:none">volume_off</button>
      <div class="storyContent">
        <h2>${item.titulo}</h2>
        <div class="date">${formateaFechaES(item.fecha)}</div>
        <p>${item.descripcion}</p>
      </div>`;
  }else{
    sec.style.backgroundImage = `url('${item.fondo}')`;
    sec.innerHTML = `
      <div class="storyContent">
        <h2>${item.titulo}</h2>
        <div class="date">${formateaFechaES(item.fecha)}</div>
        <p>${item.descripcion}</p>
      </div>`;
  }
  return sec;
}

/* buildTrack: conserva clones para looping circular */
function buildTrack(){
  track.innerHTML = "";
  if(appState.N===0) return;
  const first = crearStory(appState.recuerdos[0], 0);
  const last  = crearStory(appState.recuerdos[appState.N-1], appState.N-1);
  // agrego clones (sin asignar src aún)
  track.appendChild(last.cloneNode(true));
  appState.recuerdos.forEach((it,idx)=> track.appendChild(crearStory(it, idx)));
  track.appendChild(first.cloneNode(true));
}

/* Medida visible (altura) */
function measure(){ appState.pageH = window.innerHeight || document.documentElement.clientHeight; }

/* Transforms */
function setTransformY(y, withAnim=false){
  track.style.transition = withAnim ? "transform .35s cubic-bezier(.22,.61,.36,1)" : "none";
  track.style.transform = `translate3d(0,${y}px,0)`;
}

/* Índice real */
function realIndexFromPos(){
  let r = appState.pos - 1;
  if(r < 0) r = 0;
  if(r >= appState.N) r = appState.N-1;
  return r;
}

/* -------------------------
   LAZY-VIDEO: cargar solo current, prev y next
   ------------------------- */
function ensureVideoLoadedForIndex(idx){
  const children = track.children;
  if(!children || idx < 0 || idx >= children.length) return;
  const sec = children[idx];
  if(!sec) return;
  const v = sec.querySelector(".storyVideo");
  if(!v) return;
  if(v.dataset.loaded === "1") return; // ya cargado
  // asigno src y llamo load()
  v.src = v.dataset.src || v.getAttribute('data-src');
  try { v.load(); } catch(e){}
  v.dataset.loaded = "1";
  // si tiene botón de sonido, (re)adjunto handlers ligeros
  attachSoundControlToSection(sec);
}

/* Pausar y reproducir vídeos: más conservador (no tocar currentTime) */
function updateCounterFromPos(){
  const realIdx = realIndexFromPos();
  currentIdxEl.textContent = String(realIdx+1);
  localStorage.setItem("lastSeenIndex", realIdx);

  // bloqueo refresh si estamos en la primera storie real
  if(realIdx === 0){
    refreshBtn.classList.add("disabled");
  } else {
    refreshBtn.classList.remove("disabled");
  }

  // PRELOAD / LAZY load: cargo current, prev y next en el DOM (indices en track)
  const cur = appState.pos; // en track.children
  ensureVideoLoadedForIndex(cur);
  ensureVideoLoadedForIndex(cur-1);
  ensureVideoLoadedForIndex(cur+1);

  // pausa/stop en los que no son current
  const videos = track.querySelectorAll(".storyVideo");
  const currentSection = track.children[appState.pos];
  videos.forEach(video => {
    const parent = video.closest(".story");
    if(parent === currentSection){
      // intento play (ignorar errores de autoplay)
      video.play().catch(()=>{});
    } else {
      try{
        // pausa, pero no reseteo currentTime por defecto (evita glitches)
        video.pause();
      }catch(e){}
    }
  });

  // Lógica de newItem (se mantiene)
  const currentEl = track.children[appState.pos];
  if(currentEl && currentEl.classList.contains("newItem")){
    if(currentEl.dataset.seen === "1"){
      currentEl.classList.remove("newItem");
      const anyNewLeft = [...track.children].slice(1, appState.N+1).some(el=>el.classList.contains("newItem"));
      if(!anyNewLeft){
        newBadge.classList.remove("show");
        newBadge.style.display = "none";
        localStorage.setItem("lastCount", String(appState.N));
      }
    }else{
      currentEl.dataset.seen = "1";
    }
  }
}

/* Go to pos y normalizar clones */
function goToPos(p, animate=true){
  appState.pos = p;
  setTransformY(-appState.pos*appState.pageH, animate);
  updateCounterFromPos();

  // aseguro un fallback para evitar quedar animating=true indefinidamente
  if(appState.transitionFallbackTimer) clearTimeout(appState.transitionFallbackTimer);
  appState.transitionFallbackTimer = setTimeout(()=>{
    if(appState.animating){
      appState.animating = false;
      normalizeIfClone();
    }
  }, 800); // ligeramente mayor que la transición
}

function normalizeIfClone(){
  if(appState.pos === 0){
    appState.pos = appState.N;
    setTransformY(-appState.pos*appState.pageH, false);
  }else if(appState.pos === appState.N+1){
    appState.pos = 1;
    setTransformY(-appState.pos*appState.pageH, false);
  }
  // limpio fallback timer si se disparó normal transition
  if(appState.transitionFallbackTimer){
    clearTimeout(appState.transitionFallbackTimer);
    appState.transitionFallbackTimer = null;
  }
  updateCounterFromPos();
}

/* -------------------------
   SWIPE / DRAG (mejorado: pointer capture + document listeners)
   ------------------------- */
function onPointerDown(e){
  // solo start si no estamos en animación
  if(appState.animating) return;
  // evitar que un doble-pointer cree conflicto
  if(appState.dragging) return;
  appState.dragging = true;

  appState.activePointerId = e.pointerId;
  try{ track.setPointerCapture && track.setPointerCapture(e.pointerId); }catch(_){}
  // attach listeners al documento para asegurarnos recibir move/up aunque salga del track
  document.addEventListener('pointermove', onPointerMove, {passive:true});
  document.addEventListener('pointerup', onPointerUp, {passive:true});
  appState.startY = e.clientY;
  appState.baseY = -appState.pos*appState.pageH;
  appState.latestDelta = 0;
  appState.lastMoveTime = Date.now();
  appState.lastMoveY = e.clientY;
  appState.velocity = 0;
  track.style.transition = "none";
  e.preventDefault();

  // RAF loop para actualizar transform (suave y GPU friendly)
  const loop = ()=>{
    if(!appState.dragging) return;
    const y = appState.baseY + appState.latestDelta * 0.98;
    track.style.transform = `translate3d(0,${y}px,0)`;
    requestAnimationFrame(loop);
  };
  requestAnimationFrame(loop);

  // safety: si por alguna razón nunca recibimos pointerup (p. ej. crash), limpiamos en 3s
  if(appState.dragReleaseTimer) clearTimeout(appState.dragReleaseTimer);
  appState.dragReleaseTimer = setTimeout(()=>{
    if(appState.dragging){
      appState.dragging = false;
      appState.animating = false;
    }
  }, 3500);
}
function onPointerMove(e){
  if(!appState.dragging) return;
  // ignore other pointers
  if(e.pointerId !== appState.activePointerId) return;
  appState.latestDelta = e.clientY - appState.startY;
  const now = Date.now();
  appState.velocity = (e.clientY - appState.lastMoveY) / Math.max(16, now - appState.lastMoveTime);
  appState.lastMoveTime = now;
  appState.lastMoveY = e.clientY;
}
function onPointerUp(e){
  if(!appState.dragging) return;
  if(e.pointerId !== appState.activePointerId && appState.activePointerId !== null){
    // si es otro pointer, lo ignoramos
    return;
  }
  // limpiar listeners document
  document.removeEventListener('pointermove', onPointerMove);
  document.removeEventListener('pointerup', onPointerUp);
  try{ track.releasePointerCapture && track.releasePointerCapture(appState.activePointerId); }catch(_){}
  appState.activePointerId = null;

  appState.dragging = false;
  if(appState.dragReleaseTimer){ clearTimeout(appState.dragReleaseTimer); appState.dragReleaseTimer = null; }

  const dy = (e.clientY || appState.lastMoveY) - appState.startY;
  const v  = appState.velocity || 0;
  const shouldFlip = Math.abs(dy) > 50 || Math.abs(v) > 0.35;
  if(shouldFlip){
    if(dy > 0) appState.pos--;
    else appState.pos++;
  }
  appState.animating = true;
  goToPos(appState.pos, true);

  // Garantía: si transitionend no llega, normalizamos por fallback (ya manejado en goToPos)
  track.addEventListener("transitionend", ()=>{
    appState.animating=false;
    normalizeIfClone();
  }, {once:true});
}

let lastWheel=0;
function onWheel(e){
  const now=Date.now();
  if(appState.animating || now - lastWheel < 300) return;
  lastWheel = now;
  if(e.deltaY > 0) appState.pos++; else appState.pos--;
  appState.animating = true;
  goToPos(appState.pos, true);
  track.addEventListener("transitionend", ()=>{
    appState.animating=false; normalizeIfClone();
  }, {once:true});
}

/* Ir a índice real (1..N) */
function goToIndexReal(n){
  if(!appState.N) return;
  n = Math.max(1, Math.min(appState.N, n|0));
  appState.pos = n;
  appState.animating = true; goToPos(appState.pos, true);
  track.addEventListener("transitionend", ()=>{ appState.animating=false; normalizeIfClone(); }, {once:true});
}

/* -------------------------
   Attach sound control to a single section (idempotente)
   ------------------------- */
function attachSoundControlToSection(sec){
  if(!sec) return;
  const video = sec.querySelector('.storyVideo');
  const btn = sec.querySelector('.soundBtn');
  if(!video || !btn) return;
  if(sec._soundAttached) return; // ya atado
  sec._soundAttached = true;

  function detectAudio(){
    let hasAudio = true;
    try {
      if (typeof video.mozHasAudio !== 'undefined') {
        hasAudio = !!video.mozHasAudio;
      } else if (typeof video.webkitAudioDecodedByteCount !== 'undefined') {
        hasAudio = video.webkitAudioDecodedByteCount > 0;
      } else {
        hasAudio = true;
      }
    } catch(err){ hasAudio = true; }
    btn.style.display = hasAudio ? 'inline-flex' : 'none';
  }

  // stop propagation para evitar que el btn inicie drag en el track
  btn.addEventListener('pointerdown', e => e.stopPropagation(), {passive:true});
  btn.addEventListener('pointermove', e => e.stopPropagation(), {passive:true});
  btn.addEventListener('click', (e)=>{
    e.stopPropagation();
    try{
      if(video.muted){
        video.muted = false;
        btn.textContent = "volume_up";
      } else {
        video.muted = true;
        btn.textContent = "volume_off";
      }
    }catch(err){}
  });

  // detect audio cuando el video puede reproducirse
  video.addEventListener('canplay', detectAudio);
  // intento detectar pronto
  setTimeout(detectAudio, 250);
}

/* attachSoundControls: recorre secciones actuales y atacha control (luego lazy loader hará el resto) */
function attachSoundControls(){
  const secs = track.querySelectorAll('.story');
  secs.forEach(sec => {
    attachSoundControlToSection(sec);
  });
}

/* -------------------------
   FETCH & BUILD (mantengo lógica, pero ahora lazy load y setup robusto)
   ------------------------- */
async function fetchAndBuild(silent=false){
  let data;
  try{
    const res = await fetch(appState.RECUERDOS_JSON, {cache:"no-store"});
    data = await res.json();
  }catch(_){
    data = [{titulo:"Hola",fecha:"2025-08-21",descripcion:"Agrega recuerdos.json",fondo:"momentos/foto1.jpg"}];
  }
  appState.recuerdos = data;
  appState.N = appState.recuerdos.length;
  totalIdxEl.textContent = String(Math.max(1,appState.N));
  // preload images (ligero) pero no vídeos
  appState.recuerdos.forEach(x=>{
    if(!/\.(mp4|webm|ogg|mov)$/i.test(x.fondo)){
      const img = new Image(); img.src = x.fondo;
    }
  });

  buildTrack();
  measure();

  // Attach sound controls to sections (idempotente)
  attachSoundControls();

  // initial pos from storage
  let saved = parseInt(localStorage.getItem("lastSeenIndex") || "0");
  if(isNaN(saved) || saved<0 || saved>=appState.N) saved = 0;
  appState.pos = saved + 1;
  setTransformY(-appState.pos*appState.pageH, false);

  appState.lastKnownCount = parseInt(localStorage.getItem("lastCount") || "0");
  const hasNew = appState.N > appState.lastKnownCount;
  const nodes = [...track.children].slice(1, appState.N+1);
  nodes.forEach((el, iReal)=>{
    if(hasNew && iReal >= appState.lastKnownCount) el.classList.add("newItem");
    else el.classList.remove("newItem");
    el.dataset.seen = "";
  });
  if(hasNew){
    const diff = appState.N - appState.lastKnownCount;
    newBadge.textContent = String(diff);
    newBadge.classList.add("show");
    newBadge.style.display = "inline-block";
  }else{
    newBadge.classList.remove("show");
    newBadge.style.display = "none";
  }

  updateCounterFromPos();

  if(!appState.builtOnce){
    appState.builtOnce = true;
    // EVENTS: pointer handlers en track (pointerdown sí en track, move/up en document para robustez)
    track.addEventListener("pointerdown", onPointerDown, {passive:false});
    // pointermove & pointerup se añaden en onPointerDown al document para evitar lost events
    // wheel en stories
    stories.addEventListener("wheel", onWheel, {passive:true});
    slideSearch.addEventListener("change", ()=>{const v=parseInt(slideSearch.value,10); if(!isNaN(v)) goToIndexReal(v);});
    slideSearch.addEventListener("keydown", (e)=>{if(e.key==="Enter"){const v=parseInt(slideSearch.value,10); if(!isNaN(v)) goToIndexReal(v);}});
    window.addEventListener("resize", ()=>{const realIdx=realIndexFromPos(); measure(); appState.pos=realIdx+1; setTransformY(-appState.pos*appState.pageH,false);});
  }
}

/* REFRESH */
refreshBtn.addEventListener("click", async ()=>{
  if(refreshBtn.classList.contains("refreshing") || refreshBtn.classList.contains("disabled")) return;
  refreshBtn.classList.add("refreshing");
  await fetchAndBuild(false);
  appState.pos = 1;
  appState.animating = true; goToPos(appState.pos, true);
  track.addEventListener("transitionend", ()=>{
    appState.animating = false; normalizeIfClone();
    refreshBtn.classList.remove("refreshing");
  }, {once:true});
});

/* initial fetch */
document.addEventListener("DOMContentLoaded", async ()=>{ await fetchAndBuild(true); });

/* -------------------------
   PRIMERA INTERACCIÓN -> autounmute opcional
   ------------------------- */
let firstInteractionHandled = false;
function handleFirstInteraction(){
  if(firstInteractionHandled) return;
  firstInteractionHandled = true;
  // desmutear la storie visible si requiere autoplaySound
  const current = track.children[appState.pos];
  if(current && current.dataset.autoplaySound === "1"){
    const video = current.querySelector(".storyVideo");
    const btn = current.querySelector(".soundBtn");
    try{
      if(video){
        video.muted = false;
        if(btn) btn.textContent = "volume_up";
      }
    }catch(e){}
  }
}
document.addEventListener("pointerdown", handleFirstInteraction, {once:true});

/* -------------------------
   ANTI-ZOOM iOS + accesibilidad (mantengo)
   ------------------------- */
document.addEventListener('gesturestart', e=>e.preventDefault());
document.addEventListener('gesturechange', e=>e.preventDefault());
document.addEventListener('gestureend', e=>e.preventDefault());
let lastTouchEnd=0;
document.addEventListener('touchend', e=>{
  const now=Date.now();
  if(now-lastTouchEnd<=300){ e.preventDefault(); }
  lastTouchEnd=now;
},{passive:false});
document.addEventListener('wheel', e=>{ if(e.ctrlKey){ e.preventDefault(); } }, {passive:false});

/* SERVICE WORKER */
if('serviceWorker' in navigator){
  navigator.serviceWorker.register('service-worker.js').catch(console.error);
}
</script>
</body>
</html>